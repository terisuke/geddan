[tasks."backend:venv"]
description = "Create local Python venv for backend"
dir = "packages/backend"
run = "python3.11 -m venv venv"

[tasks."backend:install"]
description = "Install backend dependencies into venv"
dir = "packages/backend"
depends = ["backend:venv"]
run = """
source venv/bin/activate
# Skip network installs if deps are already present (offline-friendly)
python - <<'PY'
import importlib.util, sys
required = ["fastapi", "uvicorn", "redis", "celery", "magic", "httpx", "pytest"]
missing = [pkg for pkg in required if importlib.util.find_spec(pkg) is None]
if missing:
    print("Missing packages:", ", ".join(missing))
sys.exit(1 if missing else 0)
PY
if [ $? -ne 0 ]; then
  pip install --upgrade pip
  pip install -r requirements.txt
fi
"""

[tasks."backend:test"]
description = "Run backend pytest with coverage"
dir = "packages/backend"
depends = ["backend:install"]
run = "source venv/bin/activate && pytest --cov=app tests/"

[tasks."backend:serve"]
description = "Run FastAPI dev server"
dir = "packages/backend"
depends = ["backend:install"]
run = "source venv/bin/activate && uvicorn app.main:app --reload --port 8000"

[tasks."frontend:install"]
description = "Install frontend dependencies"
dir = "packages/frontend"
run = "npm install"

[tasks."frontend:dev"]
description = "Run Next.js dev server on :3000"
dir = "packages/frontend"
depends = ["frontend:install"]
run = "npm run dev"

[tasks."frontend:lint"]
description = "Run frontend lint"
dir = "packages/frontend"
depends = ["frontend:install"]
run = "npm run lint"

[tasks."frontend:test"]
description = "Run Playwright tests (uses NEXT_PUBLIC_USE_MOCK_API by default)"
dir = "packages/frontend"
depends = ["frontend:install"]
run = "npm run test"

[tasks."frontend:test:api"]
description = "Run Playwright tests against real API (requires backend + Redis + Celery running)"
dir = "packages/frontend"
depends = ["frontend:install"]
env = { NEXT_PUBLIC_USE_MOCK_API = "false", NEXT_PUBLIC_API_URL = "http://localhost:8000" }
run = "npm run test:e2e"

[tasks.e2e]
description = "Run Playwright E2E"
dir = "packages/frontend"
depends = ["frontend:install"]
run = "npm run test:e2e"

[tasks."dev:mock"]
description = "Frontend dev using mock API (no backend required)"
dir = "."
run = "mise run frontend:dev"

[tasks."dev:full"]
description = "Start backend and frontend (simple mode - requires Redis+Celery running separately, or use DEBUG=true)"
dir = "."
run = """
# Backend (in correct directory for module resolution)
pushd packages/backend >/dev/null
source venv/bin/activate
DEBUG=true REDIS_OPTIONAL=true uvicorn app.main:app --reload --port 8000 &
P1=$!
popd >/dev/null

# Frontend
pushd packages/frontend >/dev/null
NEXT_PUBLIC_USE_MOCK_API=false NEXT_PUBLIC_API_URL=http://localhost:8000 npm run dev &
P2=$!
popd >/dev/null

wait $P1 $P2
"""

[tasks."redis:start"]
description = "Start local Redis (daemonize)"
dir = "."
run = "redis-server --daemonize yes"

[tasks."redis:stop"]
description = "Stop local Redis if running"
dir = "."
run = "redis-cli shutdown || true"

[tasks."celery:worker"]
description = "Start Celery worker (detached)"
dir = "packages/backend"
depends = ["backend:install"]
run = """
source venv/bin/activate
PYTHONPATH=. celery -A app.celery_worker worker \
  --loglevel=info \
  --concurrency=2 \
  -Q video_analysis,video_generation \
  --detach \
  --pidfile=/tmp/celery.pid \
  --logfile=/tmp/celery.log
"""

[tasks."stack:start"]
description = "Start Redis + Celery + Backend + Frontend (real API)"
dir = "."
run = """
# Stop any lingering processes/ports before start
redis-cli shutdown || true
pkill -f "celery -A app.celery_worker" || true
pkill -f "uvicorn.*app.main:app" || true
pkill -f "next dev" || true
kill $(lsof -ti:8000) 2>/dev/null || true
kill $(lsof -ti:3000) 2>/dev/null || true

# Clean up old pidfiles/logfiles
rm -f /tmp/celery.pid /tmp/celery.log

# Start services
redis-server --daemonize yes
pushd packages/backend >/dev/null
source venv/bin/activate
# Start Celery worker with pidfile and logfile for reliable process management
PYTHONPATH=. celery -A app.celery_worker worker \
  --loglevel=info \
  --concurrency=2 \
  -Q video_analysis,video_generation \
  --detach \
  --pidfile=/tmp/celery.pid \
  --logfile=/tmp/celery.log
uvicorn app.main:app --port 8000 --reload &
P_BE=$!
popd >/dev/null

# Wait a moment for Celery to start
sleep 3

# Verify services are running
echo "========================================="
echo "üîç Service Status Check"
echo "========================================="
echo "Redis:"
redis-cli ping 2>/dev/null && echo "  ‚úÖ Redis is running" || echo "  ‚ùå Redis is not running"
echo ""
echo "Celery Worker:"
if [ -f /tmp/celery.pid ]; then
  CELERY_PID=$(cat /tmp/celery.pid)
  ps -p $CELERY_PID >/dev/null && echo "  ‚úÖ Celery worker is running (PID: $CELERY_PID)" || echo "  ‚ùå Celery worker failed to start (check /tmp/celery.log)"
else
  echo "  ‚ùå Celery pidfile not found"
fi
echo ""
echo "Celery Worker Health:"
pushd packages/backend >/dev/null
source venv/bin/activate
if PYTHONPATH=. celery -A app.celery_worker inspect ping >/dev/null 2>&1; then
  echo "  ‚úÖ Celery worker responding to ping"
else
  echo "  ‚ùå Celery worker not responding (trying again...)"
  sleep 2
  if PYTHONPATH=. celery -A app.celery_worker inspect ping >/dev/null 2>&1; then
    echo "  ‚úÖ Celery worker responding to ping (after retry)"
  else
    echo "  ‚ö†Ô∏è  Celery worker may still be initializing"
  fi
fi
popd >/dev/null
echo ""
echo "Task Queues:"
VIDEO_ANALYSIS_LEN=$(redis-cli llen video_analysis 2>/dev/null || echo "N/A")
VIDEO_GENERATION_LEN=$(redis-cli llen video_generation 2>/dev/null || echo "N/A")
echo "  üìä video_analysis: $VIDEO_ANALYSIS_LEN"
echo "  üìä video_generation: $VIDEO_GENERATION_LEN"
echo ""
echo "üìù Celery logs: tail -f /tmp/celery.log"
echo "========================================="

pushd packages/frontend >/dev/null
NEXT_PUBLIC_USE_MOCK_API=false NEXT_PUBLIC_API_URL=http://localhost:8000 npm run dev &
P_FE=$!
popd >/dev/null
wait $P_BE $P_FE
"""

[tasks."stack:stop"]
description = "Stop Redis + Celery + Backend + Frontend started locally"
dir = "."
run = """
echo "========================================="
echo "üõë Stopping Services"
echo "========================================="

# Stop Celery worker using pidfile (reliable)
if [ -f /tmp/celery.pid ]; then
  CELERY_PID=$(cat /tmp/celery.pid)
  echo "Stopping Celery worker (PID: $CELERY_PID)..."
  kill $CELERY_PID 2>/dev/null && echo "  ‚úÖ Celery worker stopped" || echo "  ‚ö†Ô∏è  Celery worker already stopped"
  rm -f /tmp/celery.pid
else
  echo "Celery pidfile not found, using pkill fallback..."
  pkill -f "celery -A app.celery_worker" && echo "  ‚úÖ Celery worker stopped (pkill)" || echo "  ‚ö†Ô∏è  No Celery worker found"
fi

# Stop Backend (uvicorn)
echo "Stopping Backend (uvicorn)..."
pkill -f "uvicorn.*app.main:app" && echo "  ‚úÖ Backend stopped" || echo "  ‚ö†Ô∏è  No backend process found"

# Stop Frontend (Next.js)
echo "Stopping Frontend (Next.js)..."
pkill -f "next dev" && echo "  ‚úÖ Frontend stopped" || echo "  ‚ö†Ô∏è  No frontend process found"

# Clean up task queues (optional - uncomment to clear pending tasks)
# echo "Cleaning task queues..."
# redis-cli del video_analysis 2>/dev/null && echo "  ‚úÖ Cleared video_analysis queue" || true
# redis-cli del video_generation 2>/dev/null && echo "  ‚úÖ Cleared video_generation queue" || true

# Stop Redis
echo "Stopping Redis..."
redis-cli shutdown 2>/dev/null && echo "  ‚úÖ Redis stopped" || echo "  ‚ö†Ô∏è  Redis already stopped"

# Ensure ports are freed
echo "Freeing ports..."
kill $(lsof -ti:8000) 2>/dev/null && echo "  ‚úÖ Port 8000 freed" || echo "  ‚ö†Ô∏è  Port 8000 already free"
kill $(lsof -ti:3000) 2>/dev/null && echo "  ‚úÖ Port 3000 freed" || echo "  ‚ö†Ô∏è  Port 3000 already free"

# Clean up log files (optional, comment out if you want to keep logs)
# rm -f /tmp/celery.log

echo "========================================="
echo "‚úÖ All services stopped"
echo "========================================="
"""

[tasks.clean]
description = "Clean generated upload/output artifacts"
run = "rm -rf packages/backend/uploads/* packages/backend/outputs/*"
